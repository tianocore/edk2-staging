/** @file
  Application for RSA Primitives Validation.

Copyright (c) 2010, Intel Corporation. All rights reserved.<BR>
This program and the accompanying materials
are licensed and made available under the terms and conditions of the BSD License
which accompanies this distribution.  The full text of the license may be found at
http://opensource.org/licenses/bsd-license.php

THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

**/

#include "Cryptest.h"

#define  RSA_MODULUS_LENGTH  512

//
// RSA2048 PKCS#1 Validation Data
//

//
// Public Modulus of RSA2048 Key
//
GLOBAL_REMOVE_IF_UNREFERENCED CONST UINT8  RsaN[] = {
  0xDB, 0x10, 0x1A, 0xC2, 0xA3, 0xF1, 0xDC, 0xFF, 0x13, 0x6B, 0xED, 0x44, 0xDF, 0xF0, 0x02, 0x6D,
  0x13, 0xC7, 0x88, 0xDA, 0x70, 0x6B, 0x54, 0xF1, 0xE8, 0x27, 0xDC, 0xC3, 0x0F, 0x99, 0x6A, 0xFA,
  0xC6, 0x67, 0xFF, 0x1D, 0x1E, 0x3C, 0x1D, 0xC1, 0xB5, 0x5F, 0x6C, 0xC0, 0xB2, 0x07, 0x3A, 0x6D,
  0x41, 0xE4, 0x25, 0x99, 0xAC, 0xFC, 0xD2, 0x0F, 0x02, 0xD3, 0xD1, 0x54, 0x06, 0x1A, 0x51, 0x77,
  0xBD, 0xB6, 0xBF, 0xEA, 0xA7, 0x5C, 0x06, 0xA9, 0x5D, 0x69, 0x84, 0x45, 0xD7, 0xF5, 0x05, 0xBA,
  0x47, 0xF0, 0x1B, 0xD7, 0x2B, 0x24, 0xEC, 0xCB, 0x9B, 0x1B, 0x10, 0x8D, 0x81, 0xA0, 0xBE, 0xB1,
  0x8C, 0x33, 0xE4, 0x36, 0xB8, 0x43, 0xEB, 0x19, 0x2A, 0x81, 0x8D, 0xDE, 0x81, 0x0A, 0x99, 0x48,
  0xB6, 0xF6, 0xBC, 0xCD, 0x49, 0x34, 0x3A, 0x8F, 0x26, 0x94, 0xE3, 0x28, 0x82, 0x1A, 0x7C, 0x8F,
  0x59, 0x9F, 0x45, 0xE8, 0x5D, 0x1A, 0x45, 0x76, 0x04, 0x56, 0x05, 0xA1, 0xD0, 0x1B, 0x8C, 0x77,
  0x6D, 0xAF, 0x53, 0xFA, 0x71, 0xE2, 0x67, 0xE0, 0x9A, 0xFE, 0x03, 0xA9, 0x85, 0xD2, 0xC9, 0xAA,
  0xBA, 0x2A, 0xBC, 0xF4, 0xA0, 0x08, 0xF5, 0x13, 0x98, 0x13, 0x5D, 0xF0, 0xD9, 0x33, 0x34, 0x2A,
  0x61, 0xC3, 0x89, 0x55, 0xF0, 0xAE, 0x1A, 0x9C, 0x22, 0xEE, 0x19, 0x05, 0x8D, 0x32, 0xFE, 0xEC,
  0x9C, 0x84, 0xBA, 0xB7, 0xF9, 0x6C, 0x3A, 0x4F, 0x07, 0xFC, 0x45, 0xEB, 0x12, 0xE5, 0x7B, 0xFD,
  0x55, 0xE6, 0x29, 0x69, 0xD1, 0xC2, 0xE8, 0xB9, 0x78, 0x59, 0xF6, 0x79, 0x10, 0xC6, 0x4E, 0xEB,
  0x6A, 0x5E, 0xB9, 0x9A, 0xC7, 0xC4, 0x5B, 0x63, 0xDA, 0xA3, 0x3F, 0x5E, 0x92, 0x7A, 0x81, 0x5E,
  0xD6, 0xB0, 0xE2, 0x62, 0x8F, 0x74, 0x26, 0xC2, 0x0C, 0xD3, 0x9A, 0x17, 0x47, 0xE6, 0x8E, 0xAB
};

//
// Public Exponent of RSA2048 Key
//
GLOBAL_REMOVE_IF_UNREFERENCED CONST UINT8  RsaE[] = { 0x01, 0x00, 0x01 };

//
// Private Exponent of RSA2048 Key
//
GLOBAL_REMOVE_IF_UNREFERENCED CONST UINT8  RsaD[] = {
  0x52, 0x41, 0xF4, 0xDA, 0x7B, 0xB7, 0x59, 0x55, 0xCA, 0xD4, 0x2F, 0x0F, 0x3A, 0xCB, 0xA4, 0x0D,
  0x93, 0x6C, 0xCC, 0x9D, 0xC1, 0xB2, 0xFB, 0xFD, 0xAE, 0x40, 0x31, 0xAC, 0x69, 0x52, 0x21, 0x92,
  0xB3, 0x27, 0xDF, 0xEA, 0xEE, 0x2C, 0x82, 0xBB, 0xF7, 0x40, 0x32, 0xD5, 0x14, 0xC4, 0x94, 0x12,
  0xEC, 0xB8, 0x1F, 0xCA, 0x59, 0xE3, 0xC1, 0x78, 0xF3, 0x85, 0xD8, 0x47, 0xA5, 0xD7, 0x02, 0x1A,
  0x65, 0x79, 0x97, 0x0D, 0x24, 0xF4, 0xF0, 0x67, 0x6E, 0x75, 0x2D, 0xBF, 0x10, 0x3D, 0xA8, 0x7D,
  0xEF, 0x7F, 0x60, 0xE4, 0xE6, 0x05, 0x82, 0x89, 0x5D, 0xDF, 0xC6, 0xD2, 0x6C, 0x07, 0x91, 0x33,
  0x98, 0x42, 0xF0, 0x02, 0x00, 0x25, 0x38, 0xC5, 0x85, 0x69, 0x8A, 0x7D, 0x2F, 0x95, 0x6C, 0x43,
  0x9A, 0xB8, 0x81, 0xE2, 0xD0, 0x07, 0x35, 0xAA, 0x05, 0x41, 0xC9, 0x1E, 0xAF, 0xE4, 0x04, 0x3B,
  0x19, 0xB8, 0x73, 0xA2, 0xAC, 0x4B, 0x1E, 0x66, 0x48, 0xD8, 0x72, 0x1F, 0xAC, 0xF6, 0xCB, 0xBC,
  0x90, 0x09, 0xCA, 0xEC, 0x0C, 0xDC, 0xF9, 0x2C, 0xD7, 0xEB, 0xAE, 0xA3, 0xA4, 0x47, 0xD7, 0x33,
  0x2F, 0x8A, 0xCA, 0xBC, 0x5E, 0xF0, 0x77, 0xE4, 0x97, 0x98, 0x97, 0xC7, 0x10, 0x91, 0x7D, 0x2A,
  0xA6, 0xFF, 0x46, 0x83, 0x97, 0xDE, 0xE9, 0xE2, 0x17, 0x03, 0x06, 0x14, 0xE2, 0xD7, 0xB1, 0x1D,
  0x77, 0xAF, 0x51, 0x27, 0x5B, 0x5E, 0x69, 0xB8, 0x81, 0xE6, 0x11, 0xC5, 0x43, 0x23, 0x81, 0x04,
  0x62, 0xFF, 0xE9, 0x46, 0xB8, 0xD8, 0x44, 0xDB, 0xA5, 0xCC, 0x31, 0x54, 0x34, 0xCE, 0x3E, 0x82,
  0xD6, 0xBF, 0x7A, 0x0B, 0x64, 0x21, 0x6D, 0x88, 0x7E, 0x5B, 0x45, 0x12, 0x1E, 0x63, 0x8D, 0x49,
  0xA7, 0x1D, 0xD9, 0x1E, 0x06, 0xCD, 0xE8, 0xBA, 0x2C, 0x8C, 0x69, 0x32, 0xEA, 0xBE, 0x60, 0x71
};

//
// signature input message
//
GLOBAL_REMOVE_IF_UNREFERENCED CONST CHAR8  RsaSignData[] = "OpenSSL FIPS 140-2 Public Key RSA KAT";

//
// RSA2048 SHA-256 PAD_PKCS1 signature for the above message.
// This is not FIPS 140-2 KAT, because the padding way is different.
//
GLOBAL_REMOVE_IF_UNREFERENCED CONST UINT8  RsaPkcs1Signature[] = {
  0x6E, 0x5F, 0xB3, 0x06, 0x47, 0x20, 0xE7, 0x94, 0xCE, 0xC1, 0x82, 0xD1, 0xC4, 0x8A, 0x05, 0x8F,
  0xED, 0xE7, 0x81, 0x04, 0xE6, 0x1C, 0x42, 0xE1, 0x58, 0x14, 0x5E, 0xC1, 0xE2, 0x9F, 0xBB, 0x30,
  0x43, 0xF5, 0x00, 0x54, 0x73, 0x8F, 0xF7, 0xBF, 0xE5, 0x1C, 0x18, 0xF8, 0xFB, 0xF0, 0x44, 0x0A,
  0x9E, 0xC9, 0x94, 0xF7, 0x41, 0xEF, 0x5A, 0xA7, 0x66, 0x8B, 0xB3, 0x59, 0xD7, 0xAD, 0x07, 0x81,
  0x57, 0x67, 0x6E, 0x71, 0xD9, 0xDC, 0xD6, 0x06, 0x70, 0x19, 0x49, 0xB9, 0xF4, 0x1E, 0x1E, 0x77,
  0x7C, 0xB1, 0xE9, 0xA7, 0x8D, 0xE2, 0x99, 0x9A, 0x06, 0x5E, 0xB8, 0xB0, 0x6A, 0x00, 0x9B, 0x95,
  0x11, 0xF3, 0x80, 0x89, 0x56, 0xCE, 0xE0, 0x21, 0xF2, 0xB5, 0x7A, 0x22, 0x47, 0x0E, 0xD2, 0xB8,
  0x90, 0x0A, 0x3C, 0x0F, 0x00, 0xB5, 0x7D, 0xC1, 0xB0, 0x9D, 0x7A, 0x2D, 0x6D, 0x7D, 0x34, 0x8B,
  0xF5, 0xCB, 0xCF, 0x7A, 0xEB, 0x4A, 0xDD, 0x75, 0x1C, 0x34, 0x74, 0xE7, 0x4C, 0x2A, 0x51, 0xD6,
  0x8B, 0x48, 0xCA, 0x99, 0x9F, 0x73, 0x18, 0xB6, 0x19, 0x03, 0x8A, 0x22, 0xB9, 0x8F, 0x08, 0x6C,
  0xD6, 0x6B, 0x6F, 0xBE, 0x56, 0xD2, 0x50, 0x75, 0xA9, 0x1C, 0x66, 0x47, 0x4B, 0x4F, 0x75, 0xCD,
  0x02, 0x82, 0xC3, 0xF4, 0x29, 0xAF, 0x8F, 0x31, 0xD1, 0xBE, 0x4B, 0x93, 0x31, 0x04, 0x8A, 0xD0,
  0x09, 0xC7, 0x3C, 0x20, 0xD5, 0xCC, 0xDC, 0xF6, 0xEA, 0xA8, 0x16, 0x1A, 0x3C, 0x63, 0x3C, 0xEF,
  0x63, 0xD4, 0xC1, 0xC0, 0x23, 0xE9, 0x95, 0xCF, 0x96, 0xC3, 0x6B, 0xCA, 0x61, 0xDA, 0x8F, 0xC2,
  0x2A, 0xE4, 0xEF, 0x80, 0xF1, 0x9B, 0x31, 0xFE, 0xE6, 0x58, 0x3F, 0xA9, 0x49, 0x7B, 0xDC, 0xAE,
  0x1B, 0x6D, 0x68, 0x98, 0x55, 0x9D, 0x73, 0xF0, 0xCC, 0x23, 0xC0, 0x84, 0x46, 0x67, 0x35, 0x54
};

//
// Default public key 0x10001 = 65537
//
GLOBAL_REMOVE_IF_UNREFERENCED CONST UINT8  DefaultPublicKey[] = {
  0x01, 0x00, 0x01
};

/**
  Validate UEFI-OpenSSL RSA Interfaces.

  @retval  EFI_SUCCESS  Validation succeeded.
  @retval  EFI_ABORTED  Validation failed.

**/
EFI_STATUS
ValidateCryptRsa (
  VOID
  )
{
  VOID     *Rsa;
  UINT8    HashValue[SHA256_DIGEST_SIZE];
  UINTN    HashSize;
  UINTN    CtxSize;
  VOID     *Sha1Ctx;
  UINT8    *Signature;
  UINTN    SigSize;
  BOOLEAN  Status;
  UINTN    KeySize;
  UINT8    *KeyBuffer;

  Print (L"\nUEFI-OpenSSL RSA Engine Testing: ");

  //
  // Generate & Initialize RSA Context
  //
  Rsa = RsaNew ();
  Print (L"\n- Generate RSA Context ... ");
  if (Rsa == NULL) {
    Print (L"[Fail]");
    return EFI_ABORTED;
  }

  //
  // Set/Get RSA Key Components
  //
  Print (L"Set/Get RSA Key Components ... ");

  //
  // Set/Get RSA Key N
  //
  Status = RsaSetKey (Rsa, RsaKeyN, RsaN, sizeof (RsaN));
  if (!Status) {
    Print (L"[Fail]");
    return EFI_ABORTED;
  }

  KeySize = 0;
  Status  = RsaGetKey (Rsa, RsaKeyN, NULL, &KeySize);
  if (Status || (KeySize != sizeof (RsaN))) {
    Print (L"[Fail]");
    return EFI_ABORTED;
  }

  KeyBuffer = AllocatePool (KeySize);
  Status    = RsaGetKey (Rsa, RsaKeyN, KeyBuffer, &KeySize);
  if (!Status || (KeySize != sizeof (RsaN))) {
    Print (L"[Fail]");
    return EFI_ABORTED;
  }

  if (CompareMem (KeyBuffer, RsaN, KeySize) != 0) {
    Print (L"[Fail]");
    return EFI_ABORTED;
  }

  FreePool (KeyBuffer);

  //
  // Set/Get RSA Key E
  //
  Status = RsaSetKey (Rsa, RsaKeyE, RsaE, sizeof (RsaE));
  if (!Status) {
    Print (L"[Fail]");
    return EFI_ABORTED;
  }

  KeySize = 0;
  Status  = RsaGetKey (Rsa, RsaKeyE, NULL, &KeySize);
  if (Status || (KeySize != sizeof (RsaE))) {
    Print (L"[Fail]");
    return EFI_ABORTED;
  }

  KeyBuffer = AllocatePool (KeySize);
  Status    = RsaGetKey (Rsa, RsaKeyE, KeyBuffer, &KeySize);
  if (!Status || (KeySize != sizeof (RsaE))) {
    Print (L"[Fail]");
    return EFI_ABORTED;
  }

  if (CompareMem (KeyBuffer, RsaE, KeySize) != 0) {
    Print (L"[Fail]");
    return EFI_ABORTED;
  }

  FreePool (KeyBuffer);

  //
  // Clear/Get RSA Key Components
  //
  Print (L"Clear/Get RSA Key Components ... ");

  //
  // Clear/Get RSA Key N
  //
  Status = RsaSetKey (Rsa, RsaKeyN, NULL, 0);
  if (!Status) {
    Print (L"[Fail]");
    return EFI_ABORTED;
  }

  KeySize = 1;
  Status  = RsaGetKey (Rsa, RsaKeyN, NULL, &KeySize);
  if (!Status || (KeySize != 0)) {
    Print (L"[Fail]");
    return EFI_ABORTED;
  }

  //
  // Clear/Get RSA Key E
  //
  Status = RsaSetKey (Rsa, RsaKeyE, NULL, 0);
  if (!Status) {
    Print (L"[Fail]");
    return EFI_ABORTED;
  }

  KeySize = 1;
  Status  = RsaGetKey (Rsa, RsaKeyE, NULL, &KeySize);
  if (!Status || (KeySize != 0)) {
    Print (L"[Fail]");
    return EFI_ABORTED;
  }

  //
  // Generate RSA Key Components
  //
  Print (L"Generate RSA Key Components ... ");

  Status = RsaGenerateKey (Rsa, RSA_MODULUS_LENGTH, NULL, 0);
  if (!Status) {
    Print (L"[Fail]");
    return EFI_ABORTED;
  }

  KeySize   = RSA_MODULUS_LENGTH / 8;
  KeyBuffer = AllocatePool (KeySize);
  Status    = RsaGetKey (Rsa, RsaKeyE, KeyBuffer, &KeySize);
  if (!Status) {
    Print (L"[Fail]");
    return EFI_ABORTED;
  }

  if ((KeySize != 3) ||
      (CompareMem (KeyBuffer, DefaultPublicKey, 3) != 0))
  {
    Print (L"[Fail]");
    return EFI_ABORTED;
  }

  KeySize = RSA_MODULUS_LENGTH / 8;
  Status  = RsaGetKey (Rsa, RsaKeyN, KeyBuffer, &KeySize);
  if (!Status) {
    Print (L"[Fail]");
    return EFI_ABORTED;
  }

  if (KeySize != RSA_MODULUS_LENGTH / 8) {
    Print (L"[Fail]");
    return EFI_ABORTED;
  }

  if (!RsaCheckKey (Rsa)) {
    Print (L"[Fail]");
    return EFI_ABORTED;
  }

  //
  // Check invalid RSA key components
  //
  Print (L"Check Invalid RSA Key Components ... ");

  Status = RsaSetKey (Rsa, RsaKeyN, RsaN, sizeof (RsaN));
  if (!Status) {
    Print (L"[Fail]");
    return EFI_ABORTED;
  }

  if (RsaCheckKey (Rsa)) {
    Print (L"[Fail]");
    return EFI_ABORTED;
  }

  Status = RsaSetKey (Rsa, RsaKeyN, KeyBuffer, KeySize);
  if (!Status) {
    Print (L"[Fail]");
    return EFI_ABORTED;
  }

  if (!RsaCheckKey (Rsa)) {
    Print (L"[Fail]");
    return EFI_ABORTED;
  }

  Status = RsaSetKey (Rsa, RsaKeyE, RsaE, sizeof (RsaE));
  if (!Status) {
    Print (L"[Fail]");
    return EFI_ABORTED;
  }

  if (!RsaCheckKey (Rsa)) {
    Print (L"[Fail]");
    return EFI_ABORTED;
  }

  FreePool (KeyBuffer);

  //
  // SHA-1 Digest Message for PKCS#1 Signature
  //
  Print (L"Hash Original Message ... ");
  HashSize = SHA256_DIGEST_SIZE;
  ZeroMem (HashValue, HashSize);
  CtxSize = Sha256GetContextSize ();
  Sha1Ctx = AllocatePool (CtxSize);

  Status = Sha256Init (Sha1Ctx);
  if (!Status) {
    Print (L"[Fail]");
    return EFI_ABORTED;
  }

  Status = Sha256Update (Sha1Ctx, RsaSignData, AsciiStrLen (RsaSignData));
  if (!Status) {
    Print (L"[Fail]");
    return EFI_ABORTED;
  }

  Status = Sha256Final (Sha1Ctx, HashValue);
  if (!Status) {
    Print (L"[Fail]");
    return EFI_ABORTED;
  }

  FreePool (Sha1Ctx);

  //
  // Sign RSA PKCS#1-encoded Signature
  //
  Print (L"PKCS#1 Signature ... ");

  RsaFree (Rsa);

  Rsa = RsaNew ();
  if (Rsa == NULL) {
    Print (L"[Fail]");
    return EFI_ABORTED;
  }

  Status = RsaSetKey (Rsa, RsaKeyN, RsaN, sizeof (RsaN));
  if (!Status) {
    Print (L"[Fail]");
    return EFI_ABORTED;
  }

  Status = RsaSetKey (Rsa, RsaKeyE, RsaE, sizeof (RsaE));
  if (!Status) {
    Print (L"[Fail]");
    return EFI_ABORTED;
  }

  Status = RsaSetKey (Rsa, RsaKeyD, RsaD, sizeof (RsaD));
  if (!Status) {
    Print (L"[Fail]");
    return EFI_ABORTED;
  }

  SigSize = 0;
  Status  = RsaPkcs1Sign (Rsa, HashValue, HashSize, NULL, &SigSize);
  if (Status || (SigSize == 0)) {
    Print (L"[Fail]");
    return EFI_ABORTED;
  }

  Signature = AllocatePool (SigSize);
  Status    = RsaPkcs1Sign (Rsa, HashValue, HashSize, Signature, &SigSize);
  if (!Status) {
    Print (L"[Fail]");
    return EFI_ABORTED;
  }

  if (SigSize != sizeof (RsaPkcs1Signature)) {
    Print (L"[Fail]");
    return EFI_ABORTED;
  }

  if (CompareMem (Signature, RsaPkcs1Signature, SigSize) != 0) {
    Print (L"[Fail]");
    return EFI_ABORTED;
  }

  //
  // Verify RSA PKCS#1-encoded Signature
  //

  Print (L"PKCS#1 Signature Verification ... ");

  Status = RsaPkcs1Verify (Rsa, HashValue, HashSize, Signature, SigSize);
  if (!Status) {
    Print (L"[Fail]");
    return EFI_ABORTED;
  }

  //
  // Release Resources
  //
  RsaFree (Rsa);
  Print (L"Release RSA Context ... [Pass]");

  Print (L"\n");

  return EFI_SUCCESS;
}
